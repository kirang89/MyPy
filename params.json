{"name":"Mypy","tagline":"Summary of learnings of Python (includes essential code snippets)","body":"#Learnings of Python(2.x)\r\n\r\n##Facts about Python\r\n* Python has no concept of **casting** - everything is an object (unless it's a type). You can pass any object (or type) to anywhere, and if you try to do something with it that it doesn't support, an exception will be thrown. This is one of the most basic things about python - everything has a type, but it usually doesn't matter what that is. All you deal with are references.\r\n\r\n* In many languages, an include file directive is used by the preprocessor to take all code found in the file and ‘copy’ it into the caller’s code. It is different in Python: the included code is isolated in a module namespace, which means that you generally don’t have to worry that the included code could have unwanted effects, e.g. override an existing function with the same name.\r\n\r\n* Any directory with an `__init__.py` file is considered a Python package\r\n\r\n* The `yield` keyword turns a function into a generator\r\n\r\n* Function call overhead in Python is relatively high, especially compared with the execution speed of a builtin function\r\n\r\n* The Python interpreter performs some periodic checks. In particular, it decides whether or not to let another thread run and whether or not to run a pending call (typically a call established by a signal handler)\r\n\r\n* Python Dictionaries are internally hash tables that are not ordered. When you insert elements into a dict each of their keys are hashed and then stored.\r\n\r\n\r\n##Best Practices\r\n\r\n###Data Structures(list,set,tuple,dict)\r\n\r\n* ```list.__contains__``` is O(n), and so adding the elements of another list to it is O(n2). On the other hand, ```set.__contains__``` is O(log n), so the best way to do this is to use a set to check for membership, and a list to preserve order. That way you're doing n operations that are O(log n), for a total of O(n log n), which much faster than O(n2) for reasonable values of n\r\n\r\n* If you want a dictionary to remember the order in which you inserted data and not sort it lexicographically, use [OrderedDict](http://docs.python.org/2/library/collections.html#collections.OrderedDict) instead.\r\n\r\n* To sort a list in place use the ```list.sort()``` method and to sort the list without changing it, do ```sorted(list)```\r\n\r\n###Variables\r\n\r\n* Avoid global variables wherever possible. This can not only help in writing clean, performant code but can also make it very simple to write tests and debug\r\n\r\n###Strings\r\n\r\n* Doing String concatenation either like \r\n<pre><code>''.join([num for num in xrange(loop_count)])</code></pre>\r\nor like\r\n<pre><code>  str_list = []\r\n  for num in xrange(loop_count):\r\n    str_list.append(`num`)\r\n  return ''.join(str_list)\r\n</code></pre>\r\nis a much more efficient and pythonic way of concatenation when compared to\r\n<pre><code>  out_str = ''\r\n  for num in xrange(loop_count):\r\n    out_str += `num`\r\n  return out_str\r\n</code></pre>\r\n\r\n* Instead of \r\n<pre><code>out = \"Hello\" + name + \", you seem to be \" + age + \"years old\"</code></pre>\r\ndo this \r\n<pre><code>out = \"Hello {0}, you seem to be {1} years old\".format(name, age)</code></pre>\r\n\r\n* Instead of looping over a list of words and converting them to upper case\r\n<pre><code>newlist = []\r\nfor word in oldlist:\r\n    newlist.append(word.upper())\r\n</code></pre>\r\nuse ```map``` to push the loop from the interpreter into compiled C code\r\n<pre><code>newlist = map(str.upper, oldlist)</code></pre>\r\n\r\n###Functions\r\n\r\nUsing stateless functions is a mandatory requirement for writing good, clean code in Python.\r\n\r\n###Modules\r\n\r\n* Module names should be kept small and all in lowercase, avoiding even \t  `_` when possible.\r\n\r\n\r\n*\t<pre><code>import module</code></pre> is a better practice when compared to <pre><code>from module import *</code></pre> however this is the best method: <pre><code>from module import func</code></pre>\r\n\r\n* Structure a module in the following manner:\r\n<pre><code>\r\n\"\"\"module docstring\"\"\"\r\n# imports\r\n# constants\r\n# exception classes\r\n# interface functions\r\n# classes\r\n# internal functions & classes\r\n\r\n    def main(...):\r\n  \t  ...\r\n\r\n\tif __name__ == '__main__':\r\n\r\n    \t   status = main()\r\n    \t   sys.exit(status)\r\n</code></pre>\r\n\r\n###Packages\r\n\r\n* Leaving an `__init__.py` file empty inside a package is considered normal and even a good practice, if the package’s modules and sub-packages do not need to share any code.\r\n\r\n###Exceptions\r\n\r\n* Always try and catch the expected exception instead of using the default ```except``` clause. This makes it easier to understand and debug when things go wrong.\r\n\r\n###Miscellaneous\r\n\r\n* Use exceptions to make your code cleaner and easier to read, rather than filling your code with endless branching instructions\r\n\r\n* Use a list comprehension when a computed list is the desired end result, and use a generator expression, when a computed list is the intermediate result\r\n\r\n* Use coercion if an object must be of a particular type i.e:\r\nUse `str(x)` instead of `isinstance(x, str)`\r\n\r\n* To guard certain snippets in your code, put them under a\r\n<pre><code>if \\__name\\__ == '\\__main__':</code></pre> condition\r\n\r\n* Use ```range()``` and ```xrange()``` wisely.  When you call ```range```, it creates a list of objects in memory. ```xrange``` creates a generator object which gives you the values upon iteration. Thus ```xrange``` is lightweight in memory and is thus preferred when the upper bound is large. ```xrange``` is ```range`` in Python 3.\r\n\r\n\r\n##Bad Practices\r\n\r\n* Obfuscation\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}